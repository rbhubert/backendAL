
# from sklearn.feature_extraction.text import CountVectorizer
# from sklearn.feature_extraction.text import TfidfTransformer
# from sklearn.linear_model import SGDClassifier  # support vector machine
# from sklearn.metrics import classification_report
# from sklearn.model_selection import train_test_split
# from sklearn.pipeline import Pipeline



# class TrainModel:
#     def __init__(self, preprocessing):
#         self.preprocess = preprocessing
#
#         self.classifier_SVM = Pipeline(
#             [('vect', CountVectorizer(preprocessor=self.preprocess.preprocessing)),
#              ('tfidf', TfidfTransformer()),
#              ('classifier', SGDClassifier(alpha=0.001)), ])
#
#     def train(self, train_x, train_y):
#         self.classifier_SVM = self.classifier_SVM.fit(train_x.text, train_y)
#
#     def predict(self, test_x):
#         predicted_SVM = self.classifier_SVM.predict(test_x.text)
#         return predicted_SVM
#
#     def performance(self, test_x, test_y):
#         predicted_SVM = self.classifier_SVM.predict(test_x.text)
#         print(classification_report(test_y, predicted_SVM))
#
#     def get_train_test(self):
#         dataframe = self.preprocess.get_dataframe()
#
#         # dataframe has one column 'text' and one column 'classification'
#         x = dataframe.drop(sources_base.CLASSIFICATION, axis=1)
#         y = dataframe[sources_base.CLASSIFICATION]
#
#         return train_test_split(x, y, test_size=0.20)
#
#
# class SVMModel(TrainModel):
#     def __init__(self, preprocessing):
#         super().__init__(preprocessing)
#
#         self.preprocess = preprocessing
#
#         self.classifier_SVM = Pipeline(
#             [('vect', CountVectorizer(preprocessor=self.preprocess.preprocessing)),
#              ('tfidf', TfidfTransformer()),
#              ('classifier', SGDClassifier(alpha=0.001)), ])
#
#     def train(self, train_x, train_y):
#         self.classifier_SVM = self.classifier_SVM.fit(train_x.text, train_y)
#
#     def predict(self, test_x):
#         predicted_SVM = self.classifier_SVM.predict(test_x.text)
#         return predicted_SVM
#
#     def performance(self, test_x, test_y):
#         predicted_SVM = self.classifier_SVM.predict(test_x.text)
#         print(classification_report(test_y, predicted_SVM))
#
#     def get_train_test(self):
#         dataframe = self.preprocess.get_dataframe()
#
#         # dataframe has one column 'text' and one column 'classification'
#         x = dataframe.drop(sources_base.CLASSIFICATION, axis=1)
#         y = dataframe[sources_base.CLASSIFICATION]
#
#         return train_test_split(x, y, test_size=0.20)
